# 对象实例化内存布局与访问定位

## 对象实例化

### 面试题

- 对象在JVM中是怎么存储的？
- 对象头信息里面有哪些东西？
- Java对象头有什么？

从对象创建的方式 和 步骤开始说

![image-20200709095356247](images/image-20200709095356247.png)

### 对象创建方式 

需要用到构造器的有：**new、 Class/Constructor的newInstance()方法**

- new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法
- Class的newInstance方法：在JDK9里面被标记为**过时的方法**，因为只能调用空参构造器，访问修饰符只能是public
- Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器，没有访问修饰符限制。所以取代了Class的newInstance方法
- 使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口，A对象调用clone()方法得到一个克隆对象
- 使用序列化：序列化一般用于Socket的网络传输
- 第三方库 Objenesis

### 创建对象的步骤

#### 1 判断对象对应的类是否加载、链接（验证，准备，）、初始化

虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（**即判断类元信息是否存在）**。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的 .class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。

#### 2 为对象分配内存

首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量（一个类中定义了另一个类的对象），仅分配引用变量空间即可，即4个字节大小

- 如果内存规整：指针碰撞

- 如果内存不规整
  - 虚拟表需要维护一个列表
  - 空闲列表分配

**1 如果内存是规整的**：那么虚拟机将采用的是**指针碰撞法**（Bump The Point）来为对象分配内存。意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。

**2 如果内存不是规整的**：已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是**空闲列表**来为对象分配内存。意思是虚拟机维护了一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”

**选择哪种分配方式由Java堆是否规整所决定**，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

#### 3 处理并发安全问题

- 1 采用CAS失败重试和区域加锁：保证指针更新操作的原子性
- 2 为每个线程预先分配**TLAB** (本地线程分配缓冲区)，可以通过设置 -XX:+UseTLAB参数来设置

### 4 初始化分配到的内存

内存分配结束，**虚拟机将分配到的内存空间都初始化为零值**（不包括对象头）。这一步保证了对象的实例字段的java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值。

（补充）给对象属性赋值的操作包括以下几种：

- 属性的默认初始化

- 显示初始化

- 代码块中的初始化

- 构造器初始化

  **所有属性设置默认值，保证对象实例字段在不赋值可以直接使用**


### 5 设置对象的对象头

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

### 6 执行init方法进行初始化

**在Java程序的视角看来，初始化才正式开始。**初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量

因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后接着就是执行方法，把对象按照程序员的意愿进行初始化，这**样一个真正可用的对象才算完成创建出来。**

### 总结 对象实例化的过程

- 加载类元信息
- 为对象分配内存
- 处理并发问题
- 属性的默认初始化（零值初始化）
- 设置对象头信息
- 属性的显示初始化、代码块中初始化、构造器中初始化

## 对象的内存布局

![image-20200709151033237](images/image-20200709151033237.png)



### 小结图示

![image-20200709152801713](images/image-20200709152801713.png)

## 对象的访问定位

### 图示

JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？

![image-20200709164149920](images/image-20200709164149920.png)

### 对象访问的两种方式

#### 句柄访问

![image-20200709164342002](images/image-20200709164342002.png)

句柄访问就是在栈的局部变量表中，记录的对象的引用，然后在堆空间中开辟了一块空间，也就是句柄池

#### 优点

reference中存储稳定句柄地址，对象被移动（**垃圾收集时移动对象很普遍**）时只会改变句柄中实例数据指针即可，reference本身不需要被修改

#### 直接指针（HotSpot采用）

![image-20200709164350466](images/image-20200709164350466.png)

直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据，

缺点是reference本身会随着对象被移动而修改**。** 

**但整体性能更优，所以hotspot采用这种方式**



